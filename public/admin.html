<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <title>Panel de Maestro üöÄ</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Exo+2:wght@400;700;900&display=swap');

        :root {
            --bg-color: #000011;
            --glass-bg: rgba(15, 20, 40, 0.65);
            --border-color: rgba(0, 190, 255, 0.3);
            --glow-color: #00bfff; /* Deep Sky Blue */
            --primary-accent: #ff00ff; /* Magenta/Ne√≥n */
            --text-color: #e0e0ff;
            --success-color: #00ff7f; /* Spring Green */
            --fail-color: #ff4d4d;
            --eliminate-color: #f39c12;
        }

        /* --- Fondo Estrellado Animado --- */
        @keyframes move-twink-back { from {background-position:0 0;} to {background-position:-10000px 5000px;} }
        .stars, .twinkling {
            position:fixed; top:0; left:0; right:0; bottom:0;
            width:100%; height:100%; display:block; z-index: -1;
        }
        .stars { background:#000 url(https://www.wearewebstars.com/assets/images/stars.png) repeat top center; }
        .twinkling { background:transparent url(https://www.wearewebstars.com/assets/images/twinkling.png) repeat top center; animation:move-twink-back 200s linear infinite; }

        /* --- Estilos Generales --- */
        body {
            font-family: 'Exo 2', sans-serif;
            margin: 0; padding: 20px;
            background-color: var(--bg-color); color: var(--text-color);
            display: flex; justify-content: center; align-items: flex-start; /* Ajustado para scroll */
            min-height: 100vh; text-align: center;
            overflow-y: auto; /* Permite el scroll vertical */
        }

        /* --- Contenedor de "Cristal" --- */
        .container {
            width: 100%; max-width: 500px;
            padding: 25px;
            background: var(--glass-bg);
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border: 2px solid var(--border-color);
            border-radius: 20px;
            box-shadow: 0 0 20px var(--glow-color), inset 0 0 15px rgba(0, 190, 255, 0.2);
            animation: fadeIn 1s ease-out;
        }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        
        /* --- Tipograf√≠a y T√≠tulos con Ne√≥n --- */
        h1, h2, h3 {
            font-weight: 900; text-transform: uppercase; letter-spacing: 2px;
            color: #fff;
            text-shadow: 0 0 5px #fff, 0 0 10px var(--primary-accent), 0 0 20px var(--primary-accent);
        }

        /* --- Botones y Controles Mejorados --- */
        button {
            background: transparent; color: #fff;
            border: 2px solid var(--primary-accent);
            padding: 12px 20px; border-radius: 8px; font-size: 1em; font-weight: bold;
            cursor: pointer; transition: all 0.3s ease;
            text-transform: uppercase;
            box-shadow: 0 0 5px var(--primary-accent), inset 0 0 8px rgba(255, 0, 255, 0.3);
            text-shadow: 0 0 3px #fff;
            width: 100%;
            margin-top: 10px;
        }
        button:hover:not(:disabled) {
            background: var(--primary-accent);
            box-shadow: 0 0 25px var(--primary-accent);
            transform: scale(1.05);
        }
        button:disabled {
            border-color: #555; color: #777;
            box-shadow: none; cursor: not-allowed;
        }
        input {
            width: calc(100% - 24px); padding: 12px; border: 2px solid var(--border-color);
            border-radius: 8px; font-size: 1em;
            background-color: rgba(0,0,20,0.5); color: var(--text-color);
        }
        input:focus { outline: none; border-color: var(--primary-accent); box-shadow: 0 0 10px var(--primary-accent); }

        #teacher-participants-list { list-style: none; padding: 0; }
        #teacher-participants-list li {
            background: rgba(0, 30, 60, 0.5);
            border: 1px solid var(--border-color);
            padding: 10px; margin-bottom: 5px; border-radius: 8px;
            font-size: 1.1em;
        }

        .correct { border-color: var(--success-color); box-shadow: 0 0 5px var(--success-color), inset 0 0 8px var(--success-color); }
        .correct:hover:not(:disabled) { background-color: var(--success-color); box-shadow: 0 0 25px var(--success-color); }

        .incorrect { border-color: var(--fail-color); box-shadow: 0 0 5px var(--fail-color), inset 0 0 8px var(--fail-color); }
        .incorrect:hover:not(:disabled) { background-color: var(--fail-color); box-shadow: 0 0 25px var(--fail-color); }

        .eliminate { border-color: var(--eliminate-color); box-shadow: 0 0 5px var(--eliminate-color), inset 0 0 8px var(--eliminate-color); }
        .eliminate:hover:not(:disabled) { background-color: var(--eliminate-color); box-shadow: 0 0 25px var(--eliminate-color); }

        #answer-display {
        }
    </style>
</head>
<body>
    <div class="stars"></div>
    <div class="twinkling"></div>

    <div class="container">
        <h1>Panel de Maestro</h1>
        <div id="loading" style="display: none; color: var(--primary-accent); font-weight: bold;">Actualizando...</div>
        
        <div class="control-group" id="setup-section">
            <h2>Configuraci√≥n</h2>
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <input type="text" id="topic-input" placeholder="Tema para la IA (Ej: El Sistema Solar)" style="flex-grow: 1; margin: 0;">
                <button id="fetch-categories-btn" style="width: auto; margin: 0;">Obtener Categor√≠as</button>
            </div>
            <div style="margin-bottom: 10px; text-align: left;">
                <label>
                    <input type="radio" name="category-source" value="ai" checked> Generar categor√≠as con IA
                </label>
                <label>
                    <input type="radio" name="category-source" value="manual"> Introducir categor√≠as manualmente
                </label>
            </div>
            <div id="manual-categories-container" style="display: none; margin-bottom: 10px;">
                <textarea id="manual-entries-input" rows="5" placeholder="Introduce las categor√≠as, una por l√≠nea.&#10;Ej: Geograf√≠a&#10;Historia de M√©xico&#10;Matem√°ticas"></textarea>
                <style>
                    #manual-entries-input { width: calc(100% - 28px); background-color: rgba(0,0,20,0.5); color: var(--text-color); border: 2px solid var(--border-color); border-radius: 8px; padding: 12px; font-family: inherit; }
                </style>
            </div>
            <div style="margin-bottom: 10px;">
                <label for="failures-input" style="display: block; margin-bottom: 5px;">Oportunidades por jugador:</label>
                <input type="number" id="failures-input" value="3" min="1" style="width: calc(100% - 28px);">
            </div>
            <div style="display: flex; margin: 10px 0;">
                <input type="text" id="participant-name" placeholder="Nombre del Alumno" style="flex-grow: 1;">
                <button id="add-participant-btn" style="margin:0 0 0 10px; width: auto;">A√±adir</button>
            </div>
            <ul id="teacher-participants-list"></ul>
            <button id="start-game-btn">üöÄ Iniciar Juego</button>
            <button id="reset-game-btn" class="eliminate">Reiniciar Juego</button>
        </div>

        <div class="control-group" id="game-control-section" style="display: none;">
            <h2 id="current-player-teacher"></h2>
            <div id="roulette-container" style="position: relative; max-width: 300px; margin: 20px auto;">
                <div id="arrow" style="border-left: 20px solid transparent; border-right: 20px solid transparent; border-top: 40px solid var(--primary-accent); z-index: 10; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -100%); filter: drop-shadow(0 -3px 5px var(--primary-accent));"></div>
                <canvas id="roulette-wheel"></canvas>
            </div>
            <button id="spin-btn">Girar Ruleta</button>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <button class="correct" id="correct-btn">‚úÖ Correcto</button>
                <button class="incorrect" id="incorrect-btn">‚ùå Incorrecto</button>
            </div>
            <button class="eliminate" id="eliminate-btn">Descalificar Jugador</button>
            <button id="end-game-btn" class="incorrect" style="margin-top: 20px;">Finalizar Partida</button>
        </div>
    </div>

    <script>
        const topicInput = document.getElementById('topic-input');
        const participantInput = document.getElementById('participant-name');
        const addBtn = document.getElementById('add-participant-btn');
        const list = document.getElementById('teacher-participants-list');
        const startBtn = document.getElementById('start-game-btn');
        const spinBtn = document.getElementById('spin-btn');
        const correctBtn = document.getElementById('correct-btn');
        const incorrectBtn = document.getElementById('incorrect-btn');
        const eliminateBtn = document.getElementById('eliminate-btn');
        const resetBtn = document.getElementById('reset-game-btn');
        const endGameBtn = document.getElementById('end-game-btn');
        const playerDisplay = document.getElementById('current-player-teacher');
        const setupSection = document.getElementById('setup-section');
        const gameSection = document.getElementById('game-control-section');
        const loadingDiv = document.getElementById('loading');
        const manualCategoriesContainer = document.getElementById('manual-categories-container');
        const manualEntriesInput = document.getElementById('manual-entries-input');
        const failuresInput = document.getElementById('failures-input');
        const fetchCategoriesBtn = document.getElementById('fetch-categories-btn');
        const canvas = document.getElementById('roulette-wheel');
        const ctx = canvas.getContext('2d');

        let localState = { participants: [], gameState: { status: 'waiting' } };
        let oldState = {};
        let rouletteChart = null;
        let isUpdating = false; // Flag para controlar las actualizaciones
        let fetchInterval;

        // --- Funciones para Cookies ---
        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days*24*60*60*1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (JSON.stringify(value) || "")  + expires + "; path=/";
        }
        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for(let i=0;i < ca.length;i++) {
                let c = ca[i];
                while (c.charAt(0)==' ') c = c.substring(1,c.length);
                if (c.indexOf(nameEQ) == 0) return JSON.parse(c.substring(nameEQ.length,c.length));
            }
            return null;
        }
        function eraseCookie(name) {   
            document.cookie = name+'=; Max-Age=-99999999;';  
        }

        async function updateGameState(state) {
            clearInterval(fetchInterval); // Detiene las actualizaciones autom√°ticas
            isUpdating = true; // Pausa las actualizaciones autom√°ticas
            loadingDiv.style.display = 'block';
            try {
                const response = await fetch('/api/updateState', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(state),
                });
                if (!response.ok) throw new Error('Error al actualizar.');
                await fetchGameState();
            } catch (error) { console.error(error); alert(error.message); }
            finally { 
                loadingDiv.style.display = 'none';
                isUpdating = false; // Reanuda las actualizaciones autom√°ticas
                startFetching(false); // Reinicia el intervalo sin la carga inicial
            }
        }
        
        async function fetchGameState() {
            try {
                const response = await fetch('/api/getGameState');
                const data = await response.json();
                // Solo renderizar si hay cambios reales en el estado
                if (JSON.stringify(data) === JSON.stringify(localState) || isUpdating) return;

                localState = data;
                renderUI();
            } catch (error) { console.error("Error al cargar estado.", error); }
        }

        addBtn.addEventListener('click', async () => {
            const name = participantInput.value.trim();
            if (name) {
                const newParticipants = [...localState.participants, { name, score: 0, failures: 0, isEliminated: false }];
                await updateGameState({
                    ...localState,
                    action: 'updateParticipants',
                    participants: newParticipants
                });
                participantInput.value = '';
            }
        });

        list.addEventListener('click', async (e) => {
            if (e.target.classList.contains('remove-participant-btn')) {
                const indexToRemove = parseInt(e.target.dataset.index, 10);
                const newParticipants = localState.participants.filter((_, index) => index !== indexToRemove);
                await updateGameState({ ...localState, action: 'updateParticipants', participants: newParticipants });
            }
        });

        fetchCategoriesBtn.addEventListener('click', async () => {
            const topic = topicInput.value.trim();
            if (!topic) return alert('Por favor, introduce un tema para la IA.');

            loadingDiv.style.display = 'block';
            try {
                const response = await fetch('/api/updateState', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'fetchCategories', topic: topic }),
                });
                const data = await response.json();
                manualEntriesInput.value = data.categories.join('\n');
                document.querySelector('input[name="category-source"][value="manual"]').click();
            } catch (error) { console.error(error); alert('Error al obtener categor√≠as.'); }
            finally { loadingDiv.style.display = 'none'; }
        });

        startBtn.addEventListener('click', () => {
            const categorySource = document.querySelector('input[name="category-source"]:checked').value;
            const topic = topicInput.value.trim();
            const manualCategories = manualEntriesInput.value.trim().split('\n').filter(line => line.trim() !== '');

            if (localState.participants.length < 1) {
                return alert('A√±ade al menos un participante.');
            }

            let rouletteCategories;
            if (categorySource === 'manual') {
                if (manualCategories.length < 2) {
                    return alert('Introduce al menos 2 categor√≠as manualmente.');
                }
                rouletteCategories = manualCategories;
            } else { // 'ai'
                if (!topic) {
                    return alert('Introduce un tema para que la IA genere las categor√≠as.');
                }
            }

            for (let i = localState.participants.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [localState.participants[i], localState.participants[j]] = [localState.participants[j], localState.participants[i]];
            }
            const maxFailures = parseInt(failuresInput.value, 10) || 3;

            const newState = {
                action: 'startGame',
                topic: topic,
                participants: localState.participants,
                manualEntries: null, // Ya no se usa para enviar preguntas/respuestas predefinidas
                rouletteCategories: rouletteCategories, // Env√≠a las categor√≠as manuales o null si la IA las genera
                gameState: {
                    status: 'running', 
                    maxFailures: maxFailures,
                    currentParticipantIndex: 0,
                    currentQuestion: 'Gira la ruleta', lastResult: null
                }
            };
            updateGameState(newState);
        });

        spinBtn.addEventListener('click', () => {
            const newState = { ...localState };
            newState.gameState.isSpinning = true;
            newState.gameState.spinAngle = 360 * 5 + Math.random() * 360;
            updateGameState(newState);
        });
        
        const findNextPlayerIndex = (startIndex) => {
            const totalPlayers = localState.participants.length;
            if (totalPlayers === 0) return -1;
            let nextIndex = (startIndex + 1) % totalPlayers;
            while(localState.participants[nextIndex].isEliminated) {
                nextIndex = (nextIndex + 1) % totalPlayers;
                if (nextIndex === (startIndex + 1) % totalPlayers) return -1;
            }
            return nextIndex;
        };

        const handleAnswer = (isCorrect) => {
            const newState = { ...localState };
            let currentIndex = newState.gameState.currentParticipantIndex;
            const currentPlayer = newState.participants[currentIndex];
            
            if(isCorrect) {
                currentPlayer.score += 10;
                newState.gameState.lastResult = { participantName: currentPlayer.name, result: 'correct' };
            } else {
                currentPlayer.failures += 1;
                newState.gameState.lastResult = { participantName: currentPlayer.name, result: 'incorrect' };
                if (currentPlayer.failures >= newState.gameState.maxFailures) {
                    currentPlayer.isEliminated = true;
                }
            }
            
            const nextIndex = findNextPlayerIndex(currentIndex);
            if (nextIndex === -1) {
                newState.gameState.status = 'finished';
                newState.gameState.currentQuestion = '¬°Juego Terminado!';
            } else {
                newState.gameState.currentParticipantIndex = nextIndex;
                newState.gameState.currentQuestion = 'Turno del siguiente jugador.';
            }
            
            updateGameState(newState);
        };

        eliminateBtn.addEventListener('click', () => {
            const newState = { ...localState };
            let currentIndex = newState.gameState.currentParticipantIndex;
            newState.participants[currentIndex].isEliminated = true;

            const nextIndex = findNextPlayerIndex(currentIndex);
            if (nextIndex === -1) {
                newState.gameState.status = 'finished';
                newState.gameState.currentQuestion = '¬°Juego Terminado!';
            } else {
                newState.gameState.currentParticipantIndex = nextIndex;
                newState.gameState.currentQuestion = 'Jugador eliminado. Siguiente turno.';
            }
            updateGameState(newState);
        });

        correctBtn.addEventListener('click', () => handleAnswer(true));
        incorrectBtn.addEventListener('click', () => handleAnswer(false));
        resetBtn.addEventListener('click', () => {
            if (confirm('¬øSeguro que quieres reiniciar todo el juego? Se perder√°n los participantes y la configuraci√≥n.')) {
                updateGameState({ action: 'reset', participants: [], gameState: { status: 'waiting', lastResult: null } });
            }
        });

        endGameBtn.addEventListener('click', () => {
            if (confirm('¬øSeguro?')) {
                const newState = { ...localState, action: 'endGame' };
                newState.gameState.status = 'finished';
                updateGameState(newState);
            }
        });

        document.querySelectorAll('input[name="category-source"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                manualCategoriesContainer.style.display = e.target.value === 'manual' ? 'block' : 'none';
            });
        });

        function renderUI() {
            list.innerHTML = '';
            localState.participants.forEach((p, index) => {
                const li = document.createElement('li');
                li.style.display = 'flex';
                li.style.justifyContent = 'space-between';
                li.innerHTML = `<span>${p.name}</span><button class="remove-participant-btn" data-index="${index}" style="width: auto; padding: 2px 8px; margin: 0; border-color: var(--fail-color); color: var(--fail-color); font-size: 0.8em;">‚ùå</button>`;
                list.appendChild(li);
            });

            if (localState.gameState.status === 'running') {
                setupSection.style.display = 'none';
                gameSection.style.display = 'block';
                const currentPlayer = localState.participants[localState.gameState.currentParticipantIndex];
                playerDisplay.textContent = `Turno de: ${currentPlayer ? currentPlayer.name : ''}`;
                
                const isPlayerActionable = currentPlayer && !currentPlayer.isEliminated;
                spinBtn.disabled = localState.gameState.isSpinning || !isPlayerActionable;
                correctBtn.disabled = localState.gameState.isSpinning || !isPlayerActionable;
                incorrectBtn.disabled = localState.gameState.isSpinning || !isPlayerActionable;

                // L√≥gica para dibujar y girar la ruleta
                if (localState.gameState.rouletteCategories && (!rouletteChart || JSON.stringify(rouletteChart.data.labels) !== JSON.stringify(localState.gameState.rouletteCategories))) {
                    rouletteChart = createRoulette(localState.gameState.rouletteCategories, localState.gameState.colors);
                }
                if (localState.gameState.isSpinning && oldState?.gameState?.isSpinning === false) {
                    spinTheWheel(localState.gameState);
                }

            } else {
                setupSection.style.display = 'block';
                gameSection.style.display = 'none';
            }
            // Guardar el estado actual para la pr√≥xima comparaci√≥n de giro
            oldState = JSON.parse(JSON.stringify(localState));
        }

        function createRoulette(categories, colors) {
            if (rouletteChart) rouletteChart.destroy();
            return new Chart(ctx, { type: 'doughnut', data: { labels: categories, datasets: [{ data: categories.map(() => 1), backgroundColor: colors, borderColor: 'rgba(0,0,20,0.8)', borderWidth: 4 }] }, options: { responsive: true, animation: { animateRotate: false }, plugins: { legend: { display: false }, tooltip: { enabled: false } } } });
        }

        function spinTheWheel(gameState) {
            canvas.style.transition = 'transform 6.2s cubic-bezier(0.25, 0.1, 0.25, 1)';
            canvas.style.transform = `rotate(${gameState.spinAngle}deg)`;

            // El admin es el √∫nico que calcula el resultado y pide la pregunta
            canvas.addEventListener('transitionend', () => {
                const finalRotation = gameState.spinAngle % 360;
                const sliceAngle = 360 / gameState.rouletteCategories.length;
                const selectedIndex = Math.floor((360 - finalRotation + 90) % 360 / sliceAngle);
                const category = gameState.rouletteCategories[selectedIndex];

                const newState = { 
                    ...localState,
                    action: 'generateQuestion',
                    category: category,
                };
                newState.gameState.isSpinning = false; // Asegura que los botones se reactiven
                updateGameState(newState);
            }, { once: true });
        }

        const startFetching = (initialLoad = true) => {
            // Carga inicial de participantes desde la cookie si el juego no ha empezado
            if (initialLoad) {
                fetchGameState(); // Carga inicial solo la primera vez
            }
            fetchInterval = setInterval(fetchGameState, 1700);
        };

        startFetching(true);
    </script>
</body>
</html>