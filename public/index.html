<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ruleta Cósmica</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Exo+2:wght@400;700;900&display=swap');

        :root {
            --bg-color: #000011;
            --glass-bg: rgba(15, 20, 40, 0.65);
            --border-color: rgba(0, 190, 255, 0.3);
            --glow-color: #00bfff;
            --primary-accent: #ff00ff;
            --text-color: #e0e0ff;
            --fail-color: #ff4d4d;
        }

        @keyframes move-twink-back { from {background-position:0 0;} to {background-position:-10000px 5000px;} }
        .stars, .twinkling { position:fixed; top:0; left:0; right:0; bottom:0; width:100%; height:100%; display:block; z-index: -1; }
        .stars { background:#000 url(https://www.wearewebstars.com/assets/images/stars.png) repeat top center; }
        .twinkling { background:transparent url(https://www.wearewebstars.com/assets/images/twinkling.png) repeat top center; animation:move-twink-back 200s linear infinite; }

        body {
            font-family: 'Exo 2', sans-serif;
            margin: 0; padding: 20px;
            background-color: var(--bg-color); color: var(--text-color);
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; text-align: center;
            overflow: hidden;
        }

        .container {
            width: 100%; max-width: 1400px; padding: 25px;
            background: var(--glass-bg); backdrop-filter: blur(12px);
            border: 2px solid var(--border-color); border-radius: 20px;
            box-shadow: 0 0 20px var(--glow-color), inset 0 0 15px rgba(0, 190, 255, 0.2);
            animation: fadeIn 1s ease-out;
        }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        
        h1, h2, h3 {
            font-weight: 900; text-transform: uppercase; letter-spacing: 2px;
            color: #fff;
            text-shadow: 0 0 5px #fff, 0 0 10px var(--primary-accent), 0 0 20px var(--primary-accent);
        }

        #participants-list { list-style: none; padding: 0; }
        #participants-list li {
            background: rgba(0, 30, 60, 0.5); border: 1px solid var(--border-color);
            padding: 15px; margin-bottom: 10px; border-radius: 8px;
            font-size: 1.4em; transition: all 0.3s ease;
        }
        #participants-list li.active {
            background: var(--glass-bg); border-color: var(--primary-accent);
            transform: scale(1.05);
            animation: pulse-glow 1.5s infinite alternate;
        }
        #participants-list li.eliminated {
            background: rgba(80, 0, 0, 0.7); border-color: var(--fail-color);
            text-decoration: line-through; opacity: 0.6;
        }
        @keyframes pulse-glow { from { box-shadow: 0 0 15px var(--primary-accent); } to { box-shadow: 0 0 30px #fff, 0 0 45px var(--primary-accent); } }
        
        #topic-title { font-size: 3em; }
        #current-participant-display { font-size: 2.5em; margin-top: 15px; color: var(--glow-color); }
        #question-display { font-size: 5em; font-weight: bold; color: #fff; min-height: 150px; text-shadow: 0 0 10px var(--glow-color), 0 0 20px #fff; display: flex; align-items: center; justify-content: center; }
        #arrow { border-left: 25px solid transparent; border-right: 25px solid transparent; border-top: 50px solid var(--primary-accent); z-index: 10; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -100%); filter: drop-shadow(0 -3px 5px var(--primary-accent));}
    </style>
</head>
<body>
    <div class="stars"></div>
    <div class="twinkling"></div>

    <div class="container">
        <div id="game-view" style="display: none;">
            <div id="game-area" style="display:grid; grid-template-columns: 350px 1fr; gap: 30px; align-items: center;">
                <section id="participants-section">
                    <h2>Participantes</h2>
                    <ul id="participants-list"></ul>
                </section>
                <section id="roulette-section" style="display: flex; flex-direction: column; align-items: center;">
                    <h2 id="topic-title"></h2>
                    <div id="roulette-container" style="position: relative; max-width: 500px; margin: auto;">
                        <div id="arrow"></div>
                        <canvas id="roulette-wheel"></canvas>
                    </div>
                    <h3 id="current-participant-display"></h3>
                    <div id="question-display"></div>
                </section>
            </div>
        </div>
        <div id="waiting-message">
            <h1>Esperando que la maestra inicie el juego...</h1>
        </div>
    </div>
    <script>
        const gameView = document.getElementById('game-view');
        const waitingMessage = document.getElementById('waiting-message');
        const list = document.getElementById('participants-list');
        const questionDisplay = document.getElementById('question-display');
        const topicTitle = document.getElementById('topic-title');
        const participantDisplay = document.getElementById('current-participant-display');
        const canvas = document.getElementById('roulette-wheel');
        const ctx = canvas.getContext('2d');
        
        let rouletteChart = null;
        let lastKnownState = {};

        // --- Lógica para la simulación secreta ---
        let keyHoldTimer = null;
        const KEY_TO_PRESS = 'c';
        const HOLD_DURATION = 3000; // 3 segundos

        document.addEventListener('keydown', (event) => {
            // Inicia el temporizador si se presiona la tecla 'c' y no hay un temporizador activo
            if (event.key.toLowerCase() === KEY_TO_PRESS && keyHoldTimer === null) {
                keyHoldTimer = setTimeout(() => {
                    console.log('Tecla ' + KEY_TO_PRESS + ' mantenida por 3 segundos. Abriendo simulación...');
                    window.location.href = '/simulation.html'; // Redirige a la página de simulación
                }, HOLD_DURATION);
            }
        });

        document.addEventListener('keyup', (event) => {
            // Si se suelta la tecla 'c', se cancela el temporizador
            if (event.key.toLowerCase() === KEY_TO_PRESS) {
                clearTimeout(keyHoldTimer);
                keyHoldTimer = null;
            }
        });

        async function fetchAndUpdate() {
            const response = await fetch('/gamestate.json?cache-bust=' + new Date().getTime());
            const data = await response.json();

            if (JSON.stringify(data) === JSON.stringify(lastKnownState)) return;
            lastKnownState = data;

            const { participants, gameState } = data;

            if (gameState.status !== 'running' && gameState.status !== 'finished') {
                gameView.style.display = 'none';
                waitingMessage.style.display = 'block';
                return;
            }
            if (gameState.status === 'finished') {
                waitingMessage.innerHTML = '<h1>¡Juego Terminado!</h1>';
                gameView.style.display = 'none';
                waitingMessage.style.display = 'block';
                return;
            }

            gameView.style.display = 'block';
            waitingMessage.style.display = 'none';
            
            const currentPlayer = participants[gameState.currentParticipantIndex];

            topicTitle.textContent = gameState.topic;
            participantDisplay.textContent = `Responde: ${currentPlayer.name}`;
            questionDisplay.textContent = gameState.currentQuestion;
            updateParticipantsList(participants, gameState.currentParticipantIndex);

            if (!rouletteChart || JSON.stringify(rouletteChart.data.labels) !== JSON.stringify(gameState.rouletteCategories)) {
                rouletteChart = createRoulette(gameState.rouletteCategories, gameState.colors);
            }

            if (gameState.isSpinning) {
                spinTheWheel(gameState);
                lastKnownState.gameState.isSpinning = false;
            }
        }
        
        function spinTheWheel(gameState) {
            canvas.style.transition = 'transform 5s cubic-bezier(0.25, 0.1, 0.25, 1)';
            canvas.style.transform = `rotate(${gameState.spinAngle}deg)`;

            canvas.addEventListener('transitionend', () => {
                const finalRotation = gameState.spinAngle % 360;
                const sliceAngle = 360 / gameState.rouletteCategories.length;
                const selectedIndex = Math.floor((360 - finalRotation + 90) % 360 / sliceAngle);
                const category = gameState.rouletteCategories[selectedIndex];
                
                const newState = { 
                    ...lastKnownState,
                    action: 'generateQuestion',
                    category: category,
                };
                newState.gameState.isSpinning = false;

                 fetch('/api/updateState', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(newState),
                });

            }, { once: true });
        }

        function updateParticipantsList(participants, currentIndex) {
            list.innerHTML = '';
            participants.forEach((p, index) => {
                const li = document.createElement('li');
                li.textContent = p.name;
                if(p.isEliminated) li.classList.add('eliminated');
                if (index === currentIndex && !p.isEliminated) li.classList.add('active');
                list.appendChild(li);
            });
        }
        
        function createRoulette(categories, colors) {
            if (rouletteChart) rouletteChart.destroy();
            return new Chart(ctx, {
                type: 'doughnut',
                data: { 
                    labels: categories, 
                    datasets: [{ 
                        data: categories.map(() => 1), 
                        backgroundColor: colors,
                        borderColor: 'rgba(0,0,20,0.8)',
                        borderWidth: 4
                    }] 
                },
                options: { responsive: true, animation: { animateRotate: false }, plugins: { legend: { display: false }, tooltip: { enabled: false } } }
            });
        }

        setInterval(fetchAndUpdate, 1000);
        fetchAndUpdate();
    </script>
</body>
</html>